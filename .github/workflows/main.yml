name: Build and Release for Raspberry Pi

on:
  push:
    tags:
      - 'v*'
  release:
    types: [created]
  workflow_dispatch:
    inputs:
      tag_name:
        description: 'Tag name for the release'
        required: true
        default: 'v0.1.0'

env:
  CARGO_TERM_COLOR: always

jobs:
  build:
    runs-on: ubuntu-20.04  # Use Ubuntu 20.04 for glibc 2.31 compatibility with Raspberry Pi OS 11
    strategy:
      matrix:
        include:
          - target: aarch64-unknown-linux-gnu
            gcc: gcc-aarch64-linux-gnu
            arch_name: pi-64bit
            description: "64-bit ARM (Raspberry Pi 3/4/5)"
          - target: armv7-unknown-linux-gnueabihf  
            gcc: gcc-arm-linux-gnueabihf
            arch_name: pi-32bit
            description: "32-bit ARM (Raspberry Pi 2/3/4)"
          - target: aarch64-unknown-linux-musl
            gcc: gcc-aarch64-linux-gnu
            arch_name: pi-64bit-static
            description: "64-bit ARM (Static Binary - No libc dependencies)"
          - target: armv7-unknown-linux-musleabihf
            gcc: gcc-arm-linux-gnueabihf  
            arch_name: pi-32bit-static
            description: "32-bit ARM (Static Binary - No libc dependencies)"
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Install Rust
      uses: dtolnay/rust-toolchain@stable
      with:
        targets: ${{ matrix.target }}

    - name: Install cross-compilation tools
      run: |
        sudo apt-get update
        sudo apt-get install -y ${{ matrix.gcc }}
        
        # Install musl tools if building musl targets
        if [[ "${{ matrix.target }}" == *"musl"* ]]; then
          sudo apt-get install -y musl-tools
          # Install musl cross-compilation tools
          if [[ "${{ matrix.target }}" == "aarch64"* ]]; then
            sudo apt-get install -y musl-dev gcc-aarch64-linux-gnu
          else
            sudo apt-get install -y musl-dev gcc-arm-linux-gnueabihf
          fi
        fi

    - name: Cache cargo dependencies
      uses: actions/cache@v3
      with:
        path: |
          ~/.cargo/bin/
          ~/.cargo/registry/index/
          ~/.cargo/registry/cache/
          ~/.cargo/git/db/
          target/
        key: ${{ runner.os }}-cargo-${{ matrix.target }}-${{ hashFiles('**/Cargo.lock') }}
        restore-keys: |
          ${{ runner.os }}-cargo-${{ matrix.target }}-

    - name: Configure cross-compilation
      run: |
        mkdir -p ~/.cargo
        cat >> ~/.cargo/config.toml << EOF
        [target.aarch64-unknown-linux-gnu]
        linker = "aarch64-linux-gnu-gcc"
        
        [target.armv7-unknown-linux-gnueabihf]
        linker = "arm-linux-gnueabihf-gcc"
        
        [target.aarch64-unknown-linux-musl]
        linker = "aarch64-linux-gnu-gcc"
        rustflags = ["-C", "target-feature=+crt-static"]
        
        [target.armv7-unknown-linux-musleabihf]
        linker = "arm-linux-gnueabihf-gcc"
        rustflags = ["-C", "target-feature=+crt-static"]
        EOF

    - name: Build for target
      run: |
        echo "Building for target: ${{ matrix.target }}"
        echo "Description: ${{ matrix.description }}"
        
        # Show glibc version for compatibility verification
        if [[ "${{ matrix.target }}" != *"musl"* ]]; then
          echo "Host glibc version:"
          ldd --version | head -1
        fi
        
        cargo build --release --target ${{ matrix.target }}
        
        # Verify the binary was built
        ls -la target/${{ matrix.target }}/release/uart-modbus
        
        # Show binary info (for glibc targets)
        if [[ "${{ matrix.target }}" != *"musl"* ]]; then
          echo "Binary dependencies:"
          file target/${{ matrix.target }}/release/uart-modbus
        else
          echo "Static binary info:"
          file target/${{ matrix.target }}/release/uart-modbus
        fi

    - name: Create archive name
      id: archive
      run: |
        echo "name=uart-modbus-${{ matrix.arch_name }}" >> $GITHUB_OUTPUT
        echo "file=uart-modbus-${{ matrix.arch_name }}.tar.gz" >> $GITHUB_OUTPUT

    - name: Create release archive
      run: |
        mkdir -p release/${{ steps.archive.outputs.name }}
        cp target/${{ matrix.target }}/release/uart-modbus release/${{ steps.archive.outputs.name }}/
        cp README.md release/${{ steps.archive.outputs.name }}/ 2>/dev/null || echo "README.md not found, skipping"
        cp LICENSE release/${{ steps.archive.outputs.name }}/ 2>/dev/null || echo "LICENSE not found, skipping"
        
        # Create installation script
        cat > release/${{ steps.archive.outputs.name }}/install.sh << 'EOF'
        #!/bin/bash
        set -e
        
        echo "Installing uart-modbus for Raspberry Pi..."
        
        # Check if this is a Raspberry Pi
        if [ -f /proc/device-tree/model ]; then
            PI_MODEL=$(cat /proc/device-tree/model 2>/dev/null | tr -d '\0')
            echo "Detected: $PI_MODEL"
        fi
        
        # Show binary type
        if [[ "$(basename $(pwd))" == *"static"* ]]; then
            echo "Installing static binary (no dependencies required)"
        else
            echo "Installing dynamic binary (requires glibc 2.31+)"
            echo "Current glibc version:"
            ldd --version 2>/dev/null | head -1 || echo "Unable to detect glibc version"
        fi
        
        # Make executable
        chmod +x uart-modbus
        
        # Test the binary
        echo "Testing binary..."
        if ! ./uart-modbus --help >/dev/null 2>&1; then
            echo "Warning: Binary test failed. This might indicate compatibility issues."
            echo "If you encounter issues, try the static version instead."
        fi
        
        # Copy to /usr/local/bin (requires sudo)
        if [ "$EUID" -eq 0 ]; then
            cp uart-modbus /usr/local/bin/
            echo "uart-modbus installed to /usr/local/bin/"
        else
            echo "Run with sudo to install to /usr/local/bin/, or copy manually:"
            echo "  sudo cp uart-modbus /usr/local/bin/"
        fi
        
        echo "Installation complete!"
        echo "Usage: uart-modbus"
        echo ""
        echo "Note: Ensure your user is in the 'dialout' group for UART access:"
        echo "  sudo usermod -a -G dialout \$USER"
        echo "  (logout and login again after running this command)"
        EOF
        
        chmod +x release/${{ steps.archive.outputs.name }}/install.sh
        
        cd release
        tar -czf ${{ steps.archive.outputs.file }} ${{ steps.archive.outputs.name }}

    - name: Upload build artifacts
      uses: actions/upload-artifact@v3
      with:
        name: ${{ steps.archive.outputs.name }}
        path: release/${{ steps.archive.outputs.file }}

  release:
    needs: build
    runs-on: ubuntu-latest
    if: github.event_name == 'push' && startsWith(github.ref, 'refs/tags/') || github.event_name == 'release' || github.event_name == 'workflow_dispatch'
    
    steps:
    - name: Download all artifacts
      uses: actions/download-artifact@v3

    - name: Determine tag name
      id: tag
      run: |
        if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
          echo "name=${{ github.event.inputs.tag_name }}" >> $GITHUB_OUTPUT
        elif [ "${{ github.event_name }}" = "push" ]; then
          echo "name=${GITHUB_REF#refs/tags/}" >> $GITHUB_OUTPUT
        else
          echo "name=${{ github.event.release.tag_name }}" >> $GITHUB_OUTPUT
        fi

    - name: Create Release
      id: create_release
      uses: actions/create-release@v1
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      with:
        tag_name: ${{ steps.tag.outputs.name }}
        release_name: Release ${{ steps.tag.outputs.name }}
        body: |
          # UART Modbus RTU Communication System ${{ steps.tag.outputs.name }}
          
          Cross-compiled binaries for Raspberry Pi OS 11 (Bullseye) with glibc 2.31 compatibility.
          
          ## Installation
          
          1. Download the appropriate archive for your Raspberry Pi:
             - `uart-modbus-pi-64bit.tar.gz` - For Raspberry Pi 3/4/5 (64-bit, glibc)
             - `uart-modbus-pi-32bit.tar.gz` - For Raspberry Pi 2/3/4 (32-bit, glibc)
             - `uart-modbus-pi-64bit-static.tar.gz` - For Raspberry Pi 3/4/5 (64-bit, static binary)
             - `uart-modbus-pi-32bit-static.tar.gz` - For Raspberry Pi 2/3/4 (32-bit, static binary)
          
          2. Extract and install:
             ```bash
             tar -xzf uart-modbus-pi-*.tar.gz
             cd uart-modbus-pi-*
             sudo ./install.sh
             ```
          
          ## Binary Types
          
          - **Standard binaries**: Smaller size, require compatible glibc (2.31+)
          - **Static binaries**: Larger size, no dependencies, works on any Linux system
          
          ## Usage
          
          ```bash
          uart-modbus
          ```
          
          ## Features
          
          - Modbus RTU communication over UART
          - Support for reading/writing integers, floats, and strings
          - CRC16 verification
          - Interactive menu interface
          - Configured for /dev/ttyS0 at 115200 baud
          
          ## Requirements
          
          - Raspberry Pi OS 11 (Bullseye) or compatible
          - Access to UART device (/dev/ttyS0)
          - Proper permissions for UART access
        draft: false
        prerelease: false

    - name: Upload Release Assets
      run: |
        for file in */uart-modbus-*.tar.gz; do
          if [ -f "$file" ]; then
            filename=$(basename "$file")
            echo "Uploading $filename..."
            
            curl -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
                 -H "Content-Type: application/gzip" \
                 --data-binary @"$file" \
                 "${{ steps.create_release.outputs.upload_url }}?name=${filename}&label=${filename}"
          fi
        done
